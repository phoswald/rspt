package phoswald.rspt;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

public class GeneratorJava extends Generator {

    public GeneratorJava(Grammar grammar) {
        super(grammar);
    }

    @Override
    public void generate(Writer writer) throws IOException, SyntaxException {
        if(grammar.getParser() == null) {
            grammar.setParser("Parser");
        }
        if(grammar.getCharacter() == null) {
            grammar.setCharacter("char");
        }
        for(SymbolNonTerm sym : grammar.getSymbols()) {
            if(sym.getType() == null) {
                sym.setType("Object");
            }
        }
        writeLine(writer, "//");
        writeLine(writer, "// NOTE: This file has been generated by RSPT (the Really Simple Parser Tool).");
        writeLine(writer, "//       Do not modify the contents of this file as it will be overwritten!");
        writeLine(writer, "//");
        if(grammar.getNamespace() != null) {
            writeLine(writer, "package " + grammar.getNamespace() + ";");
            writeLine(writer, "");
        }
        for(String include : grammar.getIncludes()) {
            writeLine(writer, "import " + include + ";");
        }
        writeLine(writer, "");
        writeLine(writer, "public class " + grammar.getParser() + " {");
        writeLine(writer, "");
        writeLine(writer, "    private " + grammar.getCharacter() + "[] _input;");
        writeLine(writer, "");
        writeLine(writer, "    public " + grammar.getParser() + "() { }");
        writeLine(writer, "");
        for(String code : grammar.getCodes()) {
            writeLine(writer, "    " + code + "");
        }
        for(SymbolNonTerm sym : grammar.getExports()) {
            writeLine(writer, "");
            writeLine(writer, "    public " + sym.getType() + " Parse_" + sym.getName() + "(String input) throws ParserException {");
            writeLine(writer, "        _input = input.toCharArray();");
            writeLine(writer, "        Ref_int pos = new Ref_int(0);");
            writeLine(writer, "        Ref<" + sym.getType() + "> output = new Ref<>(null);");
            writeLine(writer, "        if(nt_" + sym.getName() + "(pos, output) && pos.val == _input.length) { ");
            writeLine(writer, "            return output.val;");
            writeLine(writer, "        } else {");
            writeLine(writer, "            throw new ParserException(input, pos.val);");
            writeLine(writer, "        }");
            writeLine(writer, "    }");
        }
        boolean need_ts      = false;
        boolean need_tc      = false;
        boolean need_tset    = false;
        boolean need_trange  = false;
        boolean need_tnotset = false;
        List<String> literals = new ArrayList<>();
        for(SymbolNonTerm sym : grammar.getSymbols()) {
            boolean emptyclause = false;
            writeLine(writer, "");
            writeLine(writer, "    private boolean nt_" + sym.getName() + "(final Ref_int pos, final Ref<" + sym.getType() + "> output) {");
            writeLine(writer, "        final Ref_int pos0 = new Ref_int(pos.val);");
            for(List<Symbol> rule : sym.getRules()) {
                writeLine(writer, "        {");
                int     idx = 1;
                String  ins_to     = null;
                boolean ins_set    = false;
                boolean ins_range  = false;
                boolean ins_notset = false;
                for(Symbol sym2 : rule) {
                    if(sym2 instanceof SymbolNonTerm) {
                        SymbolNonTerm sym2nt = (SymbolNonTerm) sym2;
                        if(ins_to == null) {
                            ins_to = "output"+idx;
                            writeLine(writer, "        " + indent + "    final Ref<" + sym2nt.getType() + "> " + ins_to + " = new Ref<" + sym2nt.getType() + ">(null);");
                        }
                        writeLine(writer, "        " + indent + "    final Ref_int pos" + idx + " = new Ref_int(pos" + (idx-1) + ".val);");
                        writeLine(writer, "        " + indent + "    if(nt_" + sym2nt.getName() + "(pos" + idx + ", " + ins_to + ")) {");
                        idx++;
                        indent(4);
                        ins_to = null;
                    } else if(sym2 instanceof SymbolTerm) {
                        SymbolTerm sym2t = (SymbolTerm) sym2;
                        String func;
                        String text;
                        if(ins_set) {
                            func = "tset"; need_tset = true;
                            literals.add(sym2t.getText());
                            text = "t_" + literals.size() + " /* \"" + quoteComment(sym2t.getText()) + "\" */";
                        } else if(ins_range) {
                            func = "trange"; need_trange = true;
                            text = "\'" + quote(sym2t.getText().substring(0, 1)) + "\', \'" + quote(sym2t.getText().substring(1, 2)) + "\'";
                        } else if(ins_notset) {
                            func = "tnotset"; need_tnotset = true;
                            literals.add(sym2t.getText());
                            text = "t_" + literals.size() + " /* \"" + quoteComment(sym2t.getText()) + "\" */";
                        } else if(sym2t.getText().length() == 1) {
                            func = "tc"; need_tc = true;
                            text = "\'" + quote(sym2t.getText()) + "\'";
                        } else {
                            func = "ts"; need_ts = true;
                            literals.add(sym2t.getText());
                            text = "t_" + literals.size() + " /* \"" + quoteComment(sym2t.getText()) + "\" */";
                        }
                        writeLine(writer, "        " + indent + "    final Ref_int pos" + idx + " = new Ref_int(pos" + (idx-1) + ".val);");
                        writeLine(writer, "        " + indent + "    if(" + func + "(pos" + idx + ", " + text + ")) {");
                        idx++;
                        indent(4);
                        ins_set    = false;
                        ins_range  = false;
                        ins_notset = false;
                    } else if(sym2 instanceof SymbolCode) {
                        writeLine(writer, "        " + indent + "    " + ((SymbolCode) sym2).getCode() + ";");
                    } else if(sym2 instanceof SymbolInstr) {
                        SymbolInstr sym2i = (SymbolInstr) sym2;
                        switch(sym2i.getInstruction()) {
                            case TO:     ins_to     = sym2i.getToTarget(); break;
                            case SET:    ins_set    = true; break;
                            case RANGE:  ins_range  = true; break;
                            case NOTSET: ins_notset = true; break;
                            default: throw new SyntaxException("Invalid instruction '" + sym2i.getToken() + "'.");
                        }
                    }
                }
                if(rule.size() == 0) {
                    emptyclause = true;
                }
                writeLine(writer, "        " + indent + "    pos.val = pos" + (idx-1) + ".val;");
                writeLine(writer, "        " + indent + "    return true;");
                while(indent.length() >= 4) {
                    writeLine(writer, "        " + indent + "}");
                    indent(-4);
                }
                writeLine(writer, "        }");
            }
            if(!emptyclause) {
                writeLine(writer, "        return false;");
            }
            writeLine(writer, "    }");
        }
        if(need_ts) {
            writeLine(writer, "");
            writeLine(writer, "    private boolean ts(final Ref_int pos, " + grammar.getCharacter() + "[] s) {");
            writeLine(writer, "        for(" + grammar.getCharacter() + " c : s) {");
            writeLine(writer, "            if(pos.val >= _input.length || _input[pos.val] != c) return false;");
            writeLine(writer, "            pos.val++;");
            writeLine(writer, "        }");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        if(need_tc) {
            writeLine(writer, "");
            writeLine(writer, "    private boolean tc(final Ref_int pos, " + grammar.getCharacter() + " c) {");
            writeLine(writer, "        if(pos.val >= _input.length || _input[pos.val] != c) return false;");
            writeLine(writer, "        pos.val++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        if(need_tset) {
            writeLine(writer, "");
            writeLine(writer, "    private boolean tset(final Ref_int pos, " + grammar.getCharacter() + "[] s) {");
            writeLine(writer, "        for(int i = 0; i < s.length; i++) {");
            writeLine(writer, "            if(pos.val < _input.length && s[i] == _input[pos.val]) {");
            writeLine(writer, "                pos.val++;");
            writeLine(writer, "                return true;");
            writeLine(writer, "            }");
            writeLine(writer, "        }");
            writeLine(writer, "        return false;");
            writeLine(writer, "    }");
        }
        if(need_trange) {
            writeLine(writer, "");
            writeLine(writer, "    private boolean trange(final Ref_int pos, " + grammar.getCharacter() + " c1, " + grammar.getCharacter() + " c2) {");
            writeLine(writer, "        if(pos.val >= _input.length || _input[pos.val] < c1 || _input[pos.val] > c2) return false;");
            writeLine(writer, "        pos.val++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        if(need_tnotset) {
            writeLine(writer, "");
            writeLine(writer, "    private boolean tnotset(final Ref_int pos, " + grammar.getCharacter() + "[] s) {");
            writeLine(writer, "        for(int i = 0; i < s.length; i++) {");
            writeLine(writer, "            if(pos.val >= _input.length || s[i] == _input[pos.val]) {");
            writeLine(writer, "                return false;");
            writeLine(writer, "            }");
            writeLine(writer, "        }");
            writeLine(writer, "        pos.val++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        writeLine(writer, "");
        for (int i = 0; i < literals.size(); i++) {
            writeLine(writer, "    private static final " + grammar.getCharacter() + "[] t_" + (i+1) + " = \"" + quote(literals.get(i)) + "\".toCharArray();");
        }
        writeLine(writer, "");
        writeLine(writer, "    private static final class Ref <T> {");
        writeLine(writer, "        private T val;");
        writeLine(writer, "        private Ref(T val) { this.val = val; }");
        writeLine(writer, "    }");
        writeLine(writer, "");
        writeLine(writer, "    private static final class Ref_int {");
        writeLine(writer, "        private int val;");
        writeLine(writer, "        private Ref_int(int val) { this.val = val; }");
        writeLine(writer, "    }");
        writeLine(writer, "");
        writeLine(writer, "    public static class ParserException extends RuntimeException {");
        writeLine(writer, "        private static final long serialVersionUID = 1L;");
        writeLine(writer, "        private final String input;");
        writeLine(writer, "        private final int position;");
        writeLine(writer, "");
        writeLine(writer, "        public ParserException(String input, int position) {");
        writeLine(writer, "            this.input = input;");
        writeLine(writer, "            this.position = position;");
        writeLine(writer, "        }");
        writeLine(writer, "");
        writeLine(writer, "        public String getInput() {");
        writeLine(writer, "            return input;");
        writeLine(writer, "        }");
        writeLine(writer, "");
        writeLine(writer, "        public int getPosition() {");
        writeLine(writer, "            return position;");
        writeLine(writer, "        }");
        writeLine(writer, "    }");
        writeLine(writer, "}");
    }
}
