package phoswald.rspt;

import java.io.IOException;
import java.io.Writer;
import java.util.List;

public class GeneratorCSharp extends Generator {

    public GeneratorCSharp(Grammar grammar) {
        super(grammar);
    }

    @Override
    public void generate(Writer writer) throws IOException, SyntaxException {
        if(grammar.getParser() == null) {
            grammar.setParser("Parser");
        }
        if(grammar.getCharacter() == null) {
            grammar.setCharacter("char");
        }
        for(SymbolNonTerm sym : grammar.getSymbols()) {
            if(sym.getType() == null) {
                sym.setType("object");
            }
        }
        writeLine(writer, "//");
        writeLine(writer, "// NOTE: This file has been generated by RSPT (the Really Simple Parser Tool).");
        writeLine(writer, "//       Do not modify the contents of this file as it will be overwritten!");
        writeLine(writer, "//");
        writeLine(writer, "using System;");
        for(String include : grammar.getIncludes()) {
            writeLine(writer, "using " + include + ";");
        }
        if(grammar.getNamespace() != null) {
            writeLine(writer, "");
            writeLine(writer, "namespace " + grammar.getNamespace() + " {");
        }
        writeLine(writer, "");
        writeLine(writer, "public partial class " + grammar.getParser() + " {");
        writeLine(writer, "");
        writeLine(writer, "    private " + grammar.getCharacter() + "[] _input;");
        writeLine(writer, "");
        writeLine(writer, "    public " + grammar.getParser() + "() { }");
        for(SymbolNonTerm sym : grammar.getExports()) {
            writeLine(writer, "");
            writeLine(writer, "    public bool Parse_" + sym.getName() + "(" + grammar.getCharacter() + "[] input, out " + sym.getType() + " output, out int pos) {");
            writeLine(writer, "        _input = input;");
            writeLine(writer, "        pos    = 0;");
            writeLine(writer, "        output = default(" + sym.getType() + ");");
            writeLine(writer, "        return nt_" + sym.getName() + "(ref pos, ref output) && pos == _input.Length;");
            writeLine(writer, "    }");
        }
        boolean need_ts      = false;
        boolean need_tc      = false;
        boolean need_tset    = false;
        boolean need_trange  = false;
        boolean need_tnotset = false;
        for(SymbolNonTerm sym : grammar.getSymbols()) {
            boolean emptyclause = false;
            writeLine(writer, "");
            writeLine(writer, "    private bool nt_" + sym.getName() + "(ref int pos, ref " + sym.getType() + " output) {");
            writeLine(writer, "        int pos0 = pos;");
            for(List<Symbol> rule : sym.getRules()) {
                writeLine(writer, "        if(true) {");
                int     idx = 1;
                String  ins_to     = null;
                boolean ins_set    = false;
                boolean ins_range  = false;
                boolean ins_notset = false;
                for(Symbol sym2 : rule) {
                    if(sym2 instanceof SymbolNonTerm) {
                        SymbolNonTerm sym2nt = (SymbolNonTerm) sym2;
                        if(ins_to == null) {
                            ins_to = "output"+idx;
                            writeLine(writer, "        " + indent + "    " + sym2nt.getType() + " " + ins_to + " = default(" + sym2nt.getType() + ");");
                        }
                        writeLine(writer, "        " + indent + "    int pos" + idx + " = pos" + (idx-1) + ";");
                        writeLine(writer, "        " + indent + "    if(nt_" + sym2nt.getName() + "(ref pos" + idx + ", ref " + ins_to + ")) {");
                        idx++;
                        indent(4);
                        ins_to = null;
                    } else if(sym2 instanceof SymbolTerm) {
                        SymbolTerm sym2t = (SymbolTerm) sym2;
                        String func;
                        String text;
                        if(ins_set) {
                            func = "tset"; need_tset = true;
                            text = "\"" + quote(sym2t.text()) + "\".ToCharArray()"; // TODO inefficient, support arrays of other types
                        } else if(ins_range) {
                            func = "trange"; need_trange = true;
                            text = "\'" + quote(sym2t.text().substring(0, 1)) + "\', \'" + quote(sym2t.text().substring(1, 2)) + "\'";
                        } else if(ins_notset) {
                            func = "tnotset"; need_tset = true;
                            text = "\"" + quote(sym2t.text()) + "\".ToCharArray()"; // TODO inefficient, support arrays of other types
                        } else if(sym2t.text().length() == 1) {
                            func = "tc"; need_tc = true;
                            text = "\'" + quote(sym2t.text()) + "\'";
                        } else {
                            func = "ts"; need_ts = true;
                            text = "\"" + quote(sym2t.text()) + "\".ToCharArray()"; // TODO inefficient, support arrays of other types
                        }
                        writeLine(writer, "        " + indent + "    int pos" + idx + " = pos" + (idx-1) + ";");
                        writeLine(writer, "        " + indent + "    if(" + func + "(ref pos" + idx + ", " + text + ")) {");
                        idx++;
                        indent(4);
                        ins_set    = false;
                        ins_range  = false;
                        ins_notset = false;
                    } else if(sym2 instanceof SymbolCode) {
                        writeLine(writer, "        " + indent + "    " + ((SymbolCode) sym2).code() + ";");
                    } else if(sym2 instanceof SymbolInstr) {
                        SymbolInstr sym2i = (SymbolInstr) sym2;
                        switch(sym2i.instruction()) {
                            case TO:     ins_to     = sym2i.toResult(); break;
                            case SET:    ins_set    = true;             break;
                            case RANGE:  ins_range  = true;             break;
                            case NOTSET: ins_notset = true;             break;
                            default: throw new SyntaxException("Invalid instruction '" + sym2i.token + "'.");
                        }
                    }
                }
                if(rule.size() == 0) {
                    emptyclause = true;
                }
                writeLine(writer, "        " + indent + "    pos = pos" + (idx-1) + ";");
                writeLine(writer, "        " + indent + "    return true;");
                while(indent.length() >= 4) {
                    writeLine(writer, "        " + indent + "}");
                    indent(-4);
                }
                writeLine(writer, "        }");
            }
            if(!emptyclause) {
                writeLine(writer, "        return false;");
            }
            writeLine(writer, "    }");
        }
        if(need_ts) {
            writeLine(writer, "");
            writeLine(writer, "    private bool ts(ref int pos, " + grammar.getCharacter() + "[] s) {");
            writeLine(writer, "        foreach(" + grammar.getCharacter() + " c in s) {");
            writeLine(writer, "            if(pos >= _input.Length || _input[pos] != c) return false;");
            writeLine(writer, "            pos++;");
            writeLine(writer, "        }");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        if(need_tc) {
            writeLine(writer, "");
            writeLine(writer, "    private bool tc(ref int pos, " + grammar.getCharacter() + " c) {");
            writeLine(writer, "        if(pos >= _input.Length || _input[pos] != c) return false;");
            writeLine(writer, "        pos++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        if(need_tset) {
            writeLine(writer, "");
            writeLine(writer, "    private bool tset(ref int pos, " + grammar.getCharacter() + "[] s) {");
            writeLine(writer, "        for(int i = 0; i < s.Length; i++) {");
            writeLine(writer, "            if(pos < _input.Length && s[i] == _input[pos]) {");
            writeLine(writer, "                pos++;");
            writeLine(writer, "                return true;");
            writeLine(writer, "            }");
            writeLine(writer, "        }");
            writeLine(writer, "        return false;");
            writeLine(writer, "    }");
        }
        if(need_trange) {
            writeLine(writer, "");
            writeLine(writer, "    private bool trange(ref int pos, " + grammar.getCharacter() + " c1, " + grammar.getCharacter() + " c2) {");
            writeLine(writer, "        if(pos >= _input.Length || _input[pos] < c1 || _input[pos] > c2) return false;");
            writeLine(writer, "        pos++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        if(need_tnotset) {
            writeLine(writer, "");
            writeLine(writer, "    private bool tnotset(ref int pos, " + grammar.getCharacter() + "[] s) {");
            writeLine(writer, "        for(int i = 0; i < s.Length; i++) {");
            writeLine(writer, "            if(pos >= _input.Length || s[i] == _input[pos]) {");
            writeLine(writer, "                return false;");
            writeLine(writer, "            }");
            writeLine(writer, "        }");
            writeLine(writer, "        pos++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
        }
        writeLine(writer, "");
        for(String code : grammar.getCodes()) {
            writeLine(writer, "    " + code + "");
        }
        writeLine(writer, "}");
        if(grammar.getNamespace() != null) {
            writeLine(writer, "}");
        }
    }
}
