package phoswald.rspt;

import java.io.IOException;
import java.io.Writer;
import java.util.List;

class GeneratorCPlusPlus extends Generator {

    GeneratorCPlusPlus(Grammar grammar) {
        super(grammar);
    }

    @Override
    public void generate(Writer writer) throws IOException, SyntaxException {
        writeLine(writer, "//");
        writeLine(writer, "// NOTE: This file has been generated by RSPT (the Really Simple Parser Tool).");
        writeLine(writer, "//       Do not modify the contents of this file as it will be overwritten!");
        writeLine(writer, "//");
        writeLine(writer, "#pragma once;");
        for(String include : grammar.getImportStmts()) {
            writeLine(writer, "#include " + include + "");
        }
        if(grammar.getParserPackage() != null) {
            writeLine(writer, "");
            writeLine(writer, "namespace " + grammar.getParserPackage() + " {");
        }
        writeLine(writer, "");
        writeLine(writer, "class " + grammar.getParserClass() + "");
        writeLine(writer, "{");
        writeLine(writer, "private:");
        writeLine(writer, "    const " + grammar.getInputType() + "* _input;");
        writeLine(writer, "    int _size;");
        writeLine(writer, "");
        writeLine(writer, "public:");
        writeLine(writer, "    " + grammar.getParserClass() + "() : _input(NULL), _size(0) { }");
        for(SymbolNonTerm sym : grammar.getExports()) {
            writeLine(writer, "");
            writeLine(writer, "    bool Parse_" + sym.getName() + "(const " + grammar.getInputType() + "* input, int size, " + sym.getType() + "& output, int& pos) {");
            writeLine(writer, "        _input = input;");
            writeLine(writer, "        _size  = size;");
            writeLine(writer, "        pos    = 0;");
            writeLine(writer, "        /*output = default(" + sym.getType() + ");*/"); // TODO: fix init
            writeLine(writer, "        return nt_" + sym.getName() + "(pos, output) && pos == _size;");
            writeLine(writer, "    }");
        }
        writeLine(writer, "");
        writeLine(writer, "private:");
        boolean need_ts      = false;
        boolean need_tc      = false;
        boolean need_tset    = false;
        boolean need_trange  = false;
        boolean need_tnotset = false;
        for(SymbolNonTerm sym : grammar.getSymbols()) {
            boolean emptyclause = false;
            writeLine(writer, "    bool nt_" + sym.getName() + "(int& pos, " + sym.getType() + "& output) {");
            writeLine(writer, "        int pos0 = pos;");
            for(List<Symbol> rule : sym.getRules()) {
                writeLine(writer, "        if(true) {");
                int     idx = 1;
                String  ins_to     = null;
                boolean ins_set    = false;
                boolean ins_range  = false;
                boolean ins_notset = false;
                for(Symbol sym2 : rule) {
                    if(sym2 instanceof SymbolNonTerm) {
                        SymbolNonTerm sym2nt = (SymbolNonTerm) sym2;
                        if(ins_to == null) {
                            ins_to = "output"+idx;
                            writeLine(writer, "        " + indent + "    " + sym2nt.getType() + " " + ins_to + " /*= default(" + sym2nt.getType() + ")*/;"); // TODO: fix init
                        }
                        writeLine(writer, "        " + indent + "    int pos" + idx + " = pos" + (idx-1) + ";");
                        writeLine(writer, "        " + indent + "    if(nt_" + sym2nt.getName() + "(pos" + idx + ", " + ins_to + ")) {");
                        idx++;
                        indent(4);
                        ins_to = null;
                    } else if(sym2 instanceof SymbolTerm) {
                        SymbolTerm sym2t = (SymbolTerm) sym2;
                        String func;
                        String text;
                        if(ins_set) {
                            func = "tset"; need_tset = true;
                            text = "_T(\"" + quote(sym2t.getText()) + "\"), " + sym2t.getText().length() + ""; // TODO: support arrays of other types
                        } else if(ins_range) {
                            func = "trange"; need_trange = true;
                            text = "\'" + quote(sym2t.getText().substring(0, 1)) + "\', \'" + quote(sym2t.getText().substring(1, 2)) + "\'";
                        } else if(ins_notset) {
                            func = "tnotset"; need_tnotset = true;
                            text = "_T(\"" + quote(sym2t.getText()) + "\"), " + sym2t.getText().length() + ""; // TODO: support arrays of other types
                        } else if(sym2t.getText().length() == 1) {
                            func = "tc"; need_tc = true;
                            text = "\'" + quote(sym2t.getText()) + "\'";
                        } else {
                            func = "ts"; need_ts = true;
                            text = "_T(\"" + quote(sym2t.getText()) + "\"), " + sym2t.getText().length() + ""; // TODO: support arrays of other types
                        }
                        writeLine(writer, "        " + indent + "    int pos" + idx + " = pos" + (idx-1) + ";");
                        writeLine(writer, "        " + indent + "    if(" + func + "(pos" + idx + ", " + text + ")) {");
                        idx++;
                        indent(4);
                        ins_set    = false;
                        ins_range  = false;
                        ins_notset = false;
                    } else if(sym2 instanceof SymbolCode) {
                        writeLine(writer, "        " + indent + "    " + ((SymbolCode) sym2).getCode() + ";");
                    } else if(sym2 instanceof SymbolInstr) {
                        SymbolInstr sym2i = (SymbolInstr) sym2;
                        switch(sym2i.getInstruction()) {
                            case TO:     ins_to     = sym2i.getToTarget(); break;
                            case SET:    ins_set    = true; break;
                            case RANGE:  ins_range  = true; break;
                            case NOTSET: ins_notset = true; break;
                            default: throw new SyntaxException("Invalid instruction '" + sym2i.getToken() + "'.");
                        }
                    }
                }
                if(rule.size() == 0) {
                    emptyclause = true;
                }
                writeLine(writer, "        " + indent + "    pos = pos" + (idx-1) + ";");
                writeLine(writer, "        " + indent + "    return true;");
                while(indent.length() >= 4) {
                    writeLine(writer, "        " + indent + "}");
                    indent(-4);
                }
                writeLine(writer, "        }");
            }
            if(!emptyclause) {
                writeLine(writer, "        return false;");
            }
            writeLine(writer, "    }");
            writeLine(writer, "");
        }
        if(need_ts) {
            writeLine(writer, "    bool ts(int& pos, const " + grammar.getInputType() + "* s, int slen) {");
            writeLine(writer, "        for(int i = 0; i < slen; i++) {");
            writeLine(writer, "            if(pos >= _size || _input[pos] != s[i]) return false;");
            writeLine(writer, "            pos++;");
            writeLine(writer, "        }");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
            writeLine(writer, "");
        }
        if(need_tc) {
            writeLine(writer, "    bool tc(int& pos, " + grammar.getInputType() + " c) {");
            writeLine(writer, "        if(pos >= _size || _input[pos] != c) return false;");
            writeLine(writer, "        pos++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
            writeLine(writer, "");
        }
        if(need_tset) {
            writeLine(writer, "    bool tset(int& pos, const " + grammar.getInputType() + "* s, int slen) {");
            writeLine(writer, "        for(int i = 0; i < slen; i++) {");
            writeLine(writer, "            if(pos < _size && s[i] == _input[pos]) {");
            writeLine(writer, "                pos++;");
            writeLine(writer, "                return true;");
            writeLine(writer, "            }");
            writeLine(writer, "        }");
            writeLine(writer, "        return false;");
            writeLine(writer, "    }");
            writeLine(writer, "");
        }
        if(need_trange) {
            writeLine(writer, "    bool trange(int& pos, " + grammar.getInputType() + " c1, " + grammar.getInputType() + " c2) {");
            writeLine(writer, "        if(pos >= _size || _input[pos] < c1 || _input[pos] > c2) return false;");
            writeLine(writer, "        pos++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
            writeLine(writer, "");
        }
        if(need_tnotset) {
            writeLine(writer, "    bool tnotset(int& pos, const " + grammar.getInputType() + "* s, int slen) {");
            writeLine(writer, "        for(int i = 0; i < slen; i++) {");
            writeLine(writer, "            if(pos >= _size || s[i] == _input[pos]) {");
            writeLine(writer, "                return false;");
            writeLine(writer, "            }");
            writeLine(writer, "        }");
            writeLine(writer, "        pos++;");
            writeLine(writer, "        return true;");
            writeLine(writer, "    }");
            writeLine(writer, "");
        }
        for(String code : grammar.getCodeFragments()) {
            writeLine(writer, "    " + code + "");
        }
        writeLine(writer, "};");
        if(grammar.getParserPackage() != null) {
            writeLine(writer, "}");
        }
    }
}
